# 深入浅出Vue.js
## object 的变化侦测

- 变化侦测分为两种类型：推和拉，react 和 angular 是拉 angular 是脏检查，react 是虚拟 DOM，，vue 是推，粒度更细，精确到具体的 DOM 节点，但这样开销会很大，所以从 2.0 开始引入了虚拟 DOM，一个状态绑定的依赖不再是具体的的 DOM 节点，而是组件，从而降低依赖追踪所消耗的内存开销，vue 之所以能随意调整粒度，本质上归功于‘推’的变化侦测
- 追踪变化的两种方式：Object.defineProperty 和 es6 的 Proxy，vue2.56 版本使用的还是前者
- 如何收集依赖：在 getter 中收集依赖，在 setter 中触发依赖
- 依赖收集在一个 dep 数组中，将 dep 写成一个类，帮助管理依赖，收集，删除，发送通知
- 依赖是谁？通知谁？引入 watcher，一个集中处理的类，他是一个中介角色，数据发生变化时通知他，它再通知其他地方
- 递归侦测所有 key，封装一个 observer 类，将一个数据内的所有属性（包括子属性）都转换成 getter/setter 的形式然后去追踪他们
- Object 类型数据的变化侦测是通过 get/set 来追踪的，正是由于这种追踪，有些语法中即便数据发生了变化，vue 也追踪不到，因为 get/set 只能最总一个数据是否被修改，无法追踪新增或删除属性，为了解决这个问题，vue 提供了两个 api：vm.$set,vm.$delete,后面会详细介绍他

## Array 的变化侦测

- 使用 push 改变数组内容，由于通过 Array 原型上的方法来改变了数组的内容，所以 Object 那种 getter、setter 的实现方式就行不通了
- 如何追踪变化：拦截器，es6 之前没有提供元编程的能力，没有提供拦截原型的方法，所以要自定义方法去覆盖原生的原型方法，每当使用 Array 原型上的方法对数组进行操作时，其实执行的都是拦截器中提供的方法，从而追踪到 Array 的变化
- 要想让拦截器生效，就要使用它去覆盖 Array.prototype 但不希望直接覆盖，这样会污染全局的 Array，所以希望拦截器操作只针对那些被侦测了的数据，也就是只拦截响应式数组的原型，将数据转成响应式，又用到了 Observer，在 Observe 中使用拦截器覆盖被转成响应式的 Array 类型数据就好了
- 将拦截器方法挂载到数组的属性上:判断是否支持**proto**直接访问原型,如果不能，就直接将 arrayMethods 身上的这些方法设置到被侦测的数组上（非常粗暴）
- 拦截器的本质是为了得到一种能，一种当数组的内容发生变化时及时得到通知的能力，通知谁呢？就涉及到了如何收集数组的依赖
- 数组也是在 getter 中收集依赖，Array 在 getter 中收集依赖，在拦截其中触发依赖
- 依赖列表存放到 Observer 这个实例，这样 getter 可以访问到，拦截器也可以访问到
- ····

## 变化侦测相关 api 实现

- vm.\$watch,每个参数的作用在内部如何实现，
- vm.\$set 解决新增属性不能侦测变化
- 数据直接使用 delete 删除将无法发现数据发生变化，所以有了\$delete

---

## 虚拟 DOM

- 定义，作用类型

## patch 算法

- 什么是 patch
- 新增节点，删除节点，更新节点,移动节点
- 判断节点是否被处理过，循环节点的优化策略

## 编译模板原理

- 解析器，优化器，代码生成器
- 解析器：HTML 解析器，文本解析器（对 HTML 解析其中文本的二次加工，处理带变量的文本），解析器的大致工作流程
- 优化器：标记静态节点，然后在标记静态根节点
- 代码生成器，根据 AST，生成 with 函数所需执行的拼接字符串代码，，三种类型的节点，元素节点，文本节点，注释节点，分别对应不同的方法

## 整体流程

- Vue 开源代码的目录结构：核心通用代码，跨平台相关代码，公用工具函数
- dist 目录下针对不同平台的构建文件

## 实例方法与全局 API

- 数据相关的实例方法，事件相关的，生命周期相关的，全局 API
- 实例方法定义在 Vue 的 prototype 上，而全局 API 定义在 Vue.js 方法上

## 生命周期

- 根据整个生命周期看出各个阶段：初始化阶段，模板编译阶段（可能没有），挂载阶段，卸载阶段
- 源码角度了解生命周期，new Vue()发生了什么？\_\_init 原理，cakkhook()执行生命周期钩子。错误处理原理与 errorCaptured
- 初始化实例属性（\$开头供用户使用，\_开头供内部使用），初始化事件（v-on 事件，父子组件事件传，事件修饰符），初始化 provide/inject，inject 内部原理（，初始化的时机，自底向上搜索可用的注入内容，支持数组的形式，会被规格化，默认值逻辑）

## 指令和过滤器

- 自定义指令实现原理和内置指令实现原理：v-if, v-on, v-for
- 虚拟 Dom 钩子函数

## 过滤器

- 过滤器原理，串联的过滤器，带参数的过滤器，模板中的过滤器解析
- resloveFilter 找到对应的过滤器并返回

## 最后

- 最佳实践
- 开发项目最佳实践
  - 为列表渲染设置key
  - 为v-if|v-else使用key
  - 如何解决路由切换组件不变的问题
    - 路由导航守卫beforeRouterUpdate
    - 观察$router对象的变化
    - 为router-view组件添加属性key
  - 如何为所有路由统一添加query
    - 使用全局守卫beforeEach
    - 使用函数劫持
  - 区分Vuex和props的使用边界
  - 避免v-if和v-for同时使用
  - 为组件样式设置作用域
  - 避免在scoped中设置元素选择器
  - 避免隐形的父子组件通信
- 风格规范
  - 单文件组件如何命名
    - 文件名大小写
    - 基础组件名
    - 单例组件名
    - 紧密耦合的组件名
    - 组件名中的单词顺序
    - 完整单词的组件名
    - 组建名为多个单词
    - 模板中的组件名大小写
    - js/jsx中的组件名和大小写
  - 自闭和组件
  - prop名的大小写
  - 多个特性的元素
  - 模板中简单的表达式
  - 简单的计算属性
  - 指令缩写
  - 良好的代码顺序
    - 组件/实例的选项顺序
    - 元素特性的顺序
    - 单文件组件顶级元素的顺序


**至此，这本书的第一次阅读就结束了，感觉这本书写的真的挺不错的，也许刚开始读的时候有些不适，但也还好，过了响应式那一部分就开始舒服起来，一直到生命周期完结，都有种读起来很顺畅感觉，然后最后的生命周期，指令，过滤器，可能是近两天晚上状态不是很好，有点浮躁，就读的有些潦草，但整体读下来还是学到了很多东西，至少从整体上对vue是如何工作，有哪些组成，过去的只会使用的部分，在这本书中找到了是如何是实现的，内容很精彩笔记记得就相对较简介:)**